"""
EventNode Model - T015
Flux Self-Teaching Consciousness Emulator

Represents individual events with Mosaic observation schema for consciousness tracking.
Constitutional compliance: mock data transparency, evaluation feedback integration.
"""

from datetime import datetime
from typing import Dict, List, Optional, Any, Union
from pydantic import BaseModel, Field
from enum import Enum
import uuid


class EventType(str, Enum):
    """Types of events in consciousness system"""
    PERCEPTION = "perception"
    COGNITION = "cognition"
    ACTION = "action"
    REFLECTION = "reflection"
    INTEGRATION = "integration"
    EMERGENCE = "emergence"


class MosaicObservationType(str, Enum):
    """Mosaic observation types for consciousness tracking"""
    ATTENTION_SHIFT = "attention_shift"
    CONCEPT_ACTIVATION = "concept_activation"
    MEMORY_RETRIEVAL = "memory_retrieval"
    PATTERN_RECOGNITION = "pattern_recognition"
    GOAL_FORMATION = "goal_formation"
    DECISION_POINT = "decision_point"
    INSIGHT_MOMENT = "insight_moment"
    INTEGRATION_EVENT = "integration_event"


class MosaicObservation(BaseModel):
    """Mosaic observation schema for detailed consciousness tracking"""
    observation_id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique observation identifier")
    observation_type: MosaicObservationType = Field(..., description="Type of mosaic observation")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Observation timestamp")

    # Consciousness Measurements
    attention_level: float = Field(..., ge=0.0, le=1.0, description="Attention level during observation")
    awareness_depth: float = Field(..., ge=0.0, le=1.0, description="Depth of awareness")
    integration_strength: float = Field(..., ge=0.0, le=1.0, description="Information integration strength")

    # Contextual Information
    context_data: Dict[str, Any] = Field(default_factory=dict, description="Contextual information")
    triggered_by: Optional[str] = Field(None, description="What triggered this observation")
    related_concepts: List[str] = Field(default_factory=list, description="Related concepts")

    # Thoughtseed Integration
    attractor_influence: Dict[str, float] = Field(default_factory=dict, description="Attractor pattern influences")
    memory_context_active: List[str] = Field(default_factory=list, description="Active memory contexts")


class EventNode(BaseModel):
    """
    Event node model with Mosaic observation schema for consciousness tracking.

    Represents discrete events in the user's consciousness development journey
    with detailed mosaic observations and constitutional compliance.
    """

    # Core Identity
    event_id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique event identifier")
    user_id: str = Field(..., description="Associated user ID")
    journey_id: Optional[str] = Field(None, description="Associated autobiographical journey")
    trace_id: Optional[str] = Field(None, description="Associated thoughtseed trace")

    # Event Metadata
    created_at: datetime = Field(default_factory=datetime.utcnow, description="Event creation timestamp")
    updated_at: datetime = Field(default_factory=datetime.utcnow, description="Last event update")
    event_timestamp: datetime = Field(default_factory=datetime.utcnow, description="When the event occurred")

    # Event Classification
    event_type: EventType = Field(..., description="Type of event")
    event_name: str = Field(..., description="Human-readable event name")
    event_description: str = Field(default="", description="Detailed event description")

    # Event Content
    input_data: Dict[str, Any] = Field(default_factory=dict, description="Input data that triggered event")
    output_data: Dict[str, Any] = Field(default_factory=dict, description="Output data generated by event")
    processing_metadata: Dict[str, Any] = Field(default_factory=dict, description="Processing metadata")

    # Mosaic Observations - Core consciousness tracking
    mosaic_observations: List[MosaicObservation] = Field(default_factory=list, description="Detailed mosaic observations")
    primary_observation_type: Optional[MosaicObservationType] = Field(None, description="Primary observation type")

    # Consciousness Measurements
    consciousness_snapshot: Dict[str, float] = Field(default_factory=dict, description="Consciousness state at event time")
    emergence_indicators: List[str] = Field(default_factory=list, description="Consciousness emergence indicators")
    integration_metrics: Dict[str, float] = Field(default_factory=dict, description="Information integration metrics")

    # Temporal Context
    duration_ms: Optional[int] = Field(None, description="Event duration in milliseconds")
    sequence_position: int = Field(default=0, description="Position in event sequence")
    temporal_relationships: List[Dict[str, Any]] = Field(default_factory=list, description="Temporal relationships to other events")

    # Spatial/Conceptual Context
    concept_space_location: Dict[str, float] = Field(default_factory=dict, description="Location in concept space")
    semantic_embedding: Optional[List[float]] = Field(None, description="Semantic embedding of event")
    concept_activations: Dict[str, float] = Field(default_factory=dict, description="Activated concepts and strengths")

    # Event Relationships
    parent_event_id: Optional[str] = Field(None, description="Parent event ID")
    child_event_ids: List[str] = Field(default_factory=list, description="Child event IDs")
    related_event_ids: List[str] = Field(default_factory=list, description="Related event IDs")
    causal_relationships: List[Dict[str, Any]] = Field(default_factory=list, description="Causal relationships")

    # Impact and Significance
    significance_score: float = Field(default=0.5, ge=0.0, le=1.0, description="Event significance score")
    learning_impact: float = Field(default=0.0, ge=0.0, le=1.0, description="Learning impact score")
    consciousness_impact: float = Field(default=0.0, ge=0.0, le=1.0, description="Consciousness development impact")

    # Constitutional Compliance
    mock_data_enabled: bool = Field(default=True, description="Mock data mode for development")
    evaluation_feedback_enabled: bool = Field(default=True, description="Evaluation feedback collection enabled")
    privacy_level: str = Field(default="private", description="Event privacy level")

    # Versioning and History
    version: int = Field(default=1, description="Event version number")
    change_history: List[Dict[str, Any]] = Field(default_factory=list, description="Event change history")

    class Config:
        """Pydantic configuration"""
        use_enum_values = True
        validate_assignment = True
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

    def add_mosaic_observation(self, observation_type: MosaicObservationType,
                              attention_level: float, awareness_depth: float,
                              integration_strength: float, context_data: Dict[str, Any] = None,
                              attractor_influence: Dict[str, float] = None) -> str:
        """Add detailed mosaic observation to event"""
        observation = MosaicObservation(
            observation_type=observation_type,
            attention_level=attention_level,
            awareness_depth=awareness_depth,
            integration_strength=integration_strength,
            context_data=context_data or {},
            attractor_influence=attractor_influence or {}
        )

        self.mosaic_observations.append(observation)

        # Update primary observation if this is the first or most significant
        if (not self.primary_observation_type or
            observation.integration_strength > max([obs.integration_strength for obs in self.mosaic_observations[:-1]], default=0)):
            self.primary_observation_type = observation_type

        self.updated_at = datetime.utcnow()
        return observation.observation_id

    def update_consciousness_snapshot(self, metrics: Dict[str, float]) -> None:
        """Update consciousness state snapshot"""
        self.consciousness_snapshot.update(metrics)
        self.updated_at = datetime.utcnow()

        # Update derived metrics
        if metrics:
            avg_consciousness = sum(metrics.values()) / len(metrics)
            self.consciousness_impact = max(self.consciousness_impact, avg_consciousness)

    def add_causal_relationship(self, related_event_id: str, relationship_type: str,
                              strength: float, description: str = "") -> None:
        """Add causal relationship to another event"""
        relationship = {
            "related_event_id": related_event_id,
            "relationship_type": relationship_type,  # "causes", "enables", "inhibits", "correlates"
            "strength": strength,
            "description": description,
            "created_at": datetime.utcnow().isoformat()
        }

        self.causal_relationships.append(relationship)

        if related_event_id not in self.related_event_ids:
            self.related_event_ids.append(related_event_id)

        self.updated_at = datetime.utcnow()

    def calculate_significance_score(self) -> float:
        """Calculate event significance based on multiple factors"""
        factors = []

        # Consciousness impact
        if self.consciousness_snapshot:
            avg_consciousness = sum(self.consciousness_snapshot.values()) / len(self.consciousness_snapshot)
            factors.append(avg_consciousness)

        # Integration strength from mosaic observations
        if self.mosaic_observations:
            avg_integration = sum(obs.integration_strength for obs in self.mosaic_observations) / len(self.mosaic_observations)
            factors.append(avg_integration)

        # Causal relationship count (normalized)
        causal_factor = min(len(self.causal_relationships) / 5.0, 1.0)
        factors.append(causal_factor)

        # Learning impact
        factors.append(self.learning_impact)

        if factors:
            self.significance_score = sum(factors) / len(factors)
        else:
            self.significance_score = 0.5

        return self.significance_score

    def get_dominant_mosaic_patterns(self) -> Dict[str, Any]:
        """Get dominant patterns from mosaic observations"""
        if not self.mosaic_observations:
            return {}

        # Analyze observation types
        type_counts = {}
        attention_levels = []
        integration_levels = []

        for obs in self.mosaic_observations:
            obs_type = obs.observation_type.value
            type_counts[obs_type] = type_counts.get(obs_type, 0) + 1
            attention_levels.append(obs.attention_level)
            integration_levels.append(obs.integration_strength)

        return {
            "dominant_observation_type": max(type_counts, key=type_counts.get) if type_counts else None,
            "observation_diversity": len(type_counts),
            "avg_attention": sum(attention_levels) / len(attention_levels) if attention_levels else 0,
            "avg_integration": sum(integration_levels) / len(integration_levels) if integration_levels else 0,
            "total_observations": len(self.mosaic_observations)
        }

    def add_temporal_relationship(self, related_event_id: str, relationship_type: str,
                                 time_delta_ms: int) -> None:
        """Add temporal relationship to another event"""
        relationship = {
            "related_event_id": related_event_id,
            "relationship_type": relationship_type,  # "before", "after", "during", "overlaps"
            "time_delta_ms": time_delta_ms,
            "created_at": datetime.utcnow().isoformat()
        }

        self.temporal_relationships.append(relationship)
        self.updated_at = datetime.utcnow()

    def create_child_event(self, event_type: EventType, event_name: str,
                          event_description: str = "") -> str:
        """Create child event and return its ID"""
        child_event_id = str(uuid.uuid4())
        self.child_event_ids.append(child_event_id)
        self.updated_at = datetime.utcnow()
        return child_event_id

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return self.dict()

    @classmethod
    def create_mock_event(cls, user_id: str, event_type: EventType,
                         event_name: str, journey_id: str = None) -> "EventNode":
        """
        Create mock event node for development/testing.
        Constitutional compliance: clearly marked as mock data.
        """
        event = cls(
            user_id=user_id,
            journey_id=journey_id,
            event_type=event_type,
            event_name=event_name,
            event_description=f"Mock {event_type.value} event: {event_name}",
            mock_data_enabled=True,
            consciousness_snapshot={
                "attention": 0.7,
                "awareness": 0.6,
                "integration": 0.5,
                "meta_cognition": 0.4
            },
            concept_activations={
                "consciousness": 0.8,
                "attention": 0.7,
                "awareness": 0.6
            },
            significance_score=0.6,
            learning_impact=0.5
        )

        # Add mock mosaic observation
        event.add_mosaic_observation(
            MosaicObservationType.PATTERN_RECOGNITION,
            attention_level=0.7,
            awareness_depth=0.6,
            integration_strength=0.5,
            context_data={"mock_context": True, "pattern_type": "consciousness_pattern"},
            attractor_influence={"working_memory": 0.6, "attention": 0.7}
        )

        return event


# Type aliases for convenience
EventNodeDict = Dict[str, Any]
EventNodeList = List[EventNode]